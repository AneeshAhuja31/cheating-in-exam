#include <iostream>
    #include <pthread.h>
    #include <unistd.h>
    using namespace std;
    
    class Monitor {
    private:
        int rcnt;   // number of active readers
        int wcnt;   // 1 if a writer is active
        int waitr;  // number of waiting readers
        int waitw;  // number of waiting writers
    
        pthread_cond_t canread;
        pthread_cond_t canwrite;
        pthread_mutex_t condlock;
    
    public:
        Monitor() {
            rcnt = wcnt = waitr = waitw = 0;
            pthread_cond_init(&canread, NULL);
            pthread_cond_init(&canwrite, NULL);
            pthread_mutex_init(&condlock, NULL);
        }
    
        void beginread(int i) {
            pthread_mutex_lock(&condlock);
    
            while (wcnt == 1 || waitw > 0) {
                waitr++;
                pthread_cond_wait(&canread, &condlock);
                waitr--;
            }
    
            rcnt++;
            cout << "Reader " << i << " is reading\n";
    
            pthread_mutex_unlock(&condlock);
        }
    
        void endread(int i) {
            pthread_mutex_lock(&condlock);
    
            rcnt--;
            if (rcnt == 0)
                pthread_cond_signal(&canwrite);  // writer can go now
    
            pthread_mutex_unlock(&condlock);
        }
    
        void beginwrite(int i) {
            pthread_mutex_lock(&condlock);
    
            while (wcnt == 1 || rcnt > 0) {
                waitw++;
                pthread_cond_wait(&canwrite, &condlock);
                waitw--;
            }
    
            wcnt = 1;
            cout << "Writer " << i << " is writing\n";
    
            pthread_mutex_unlock(&condlock);
        }
    
        void endwrite(int i) {
            pthread_mutex_lock(&condlock);
    
            wcnt = 0;
            if (waitr > 0)
                pthread_cond_broadcast(&canread);  // wake all readers
            else if (waitw > 0)
                pthread_cond_signal(&canwrite);
    
            pthread_mutex_unlock(&condlock);
        }
    } M;
    
    void* reader(void* id) {
        int i = *(int*)id;
        for (int c = 0; c < 5; c++) {
            usleep(1000);
            M.beginread(i);
            M.endread(i);
        }
        return NULL;
    }
    
    void* writer(void* id) {
        int i = *(int*)id;
        for (int c = 0; c < 5; c++) {
            usleep(1000);
            M.beginwrite(i);
            M.endwrite(i);
        }
        return NULL;
    }
    
    int main() {
        pthread_t r[5], w[5];
        int id[5];
    
        for (int i = 0; i < 5; i++) {
            id[i] = i;
            pthread_create(&r[i], NULL, reader, &id[i]);
            pthread_create(&w[i], NULL, writer, &id[i]);
        }
    
        for (int i = 0; i < 5; i++) {
            pthread_join(r[i], NULL);
            pthread_join(w[i], NULL);
        }
    
        return 0;
    }
    